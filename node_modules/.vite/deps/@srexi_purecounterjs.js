import {
  __commonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@srexi/purecounterjs/dist/purecounter.js
var require_purecounter = __commonJS({
  "node_modules/@srexi/purecounterjs/dist/purecounter.js"(exports, module) {
    !function(e, t) {
      "object" == typeof exports && "object" == typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define([], t) : "object" == typeof exports ? exports.PureCounter = t() : e.PureCounter = t();
    }(self, function() {
      return function() {
        var e = { 3: function(e2, t2, r2) {
          "use strict";
          function n(e3) {
            return function(e4) {
              if (Array.isArray(e4)) return i(e4);
            }(e3) || function(e4) {
              if ("undefined" != typeof Symbol && null != e4[Symbol.iterator] || null != e4["@@iterator"]) return Array.from(e4);
            }(e3) || function(e4, t3) {
              if (!e4) return;
              if ("string" == typeof e4) return i(e4, t3);
              var r3 = Object.prototype.toString.call(e4).slice(8, -1);
              "Object" === r3 && e4.constructor && (r3 = e4.constructor.name);
              if ("Map" === r3 || "Set" === r3) return Array.from(e4);
              if ("Arguments" === r3 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r3)) return i(e4, t3);
            }(e3) || function() {
              throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
            }();
          }
          function i(e3, t3) {
            (null == t3 || t3 > e3.length) && (t3 = e3.length);
            for (var r3 = 0, n2 = new Array(t3); r3 < t3; r3++) n2[r3] = e3[r3];
            return n2;
          }
          function o(e3, t3) {
            if (!(e3 instanceof t3)) throw new TypeError("Cannot call a class as a function");
          }
          function a(e3, t3) {
            for (var r3 = 0; r3 < t3.length; r3++) {
              var n2 = t3[r3];
              n2.enumerable = n2.enumerable || false, n2.configurable = true, "value" in n2 && (n2.writable = true), Object.defineProperty(e3, n2.key, n2);
            }
          }
          r2.d(t2, { Z: function() {
            return s;
          } });
          var s = function() {
            function e3() {
              var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
              o(this, e3), this.defaults = { start: 0, end: 100, duration: 2e3, delay: 10, once: true, pulse: false, decimals: 0, legacy: true, filesizing: false, currency: false, separator: false, formater: "us-US", selector: ".purecounter" }, this.configOptions = this.setOptions(t4, this.defaults), this.elements = document.querySelectorAll(this.configOptions.selector), this.intersectionSupport = this.intersectionListenerSupported(), this.registerEventListeners();
            }
            var t3, r3, i2;
            return t3 = e3, r3 = [{ key: "setOptions", value: function(e4) {
              var t4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, r4 = {};
              for (var n2 in e4) if (0 === Object.keys(t4).length || t4.hasOwnProperty(n2)) {
                var i3 = this.parseValue(e4[n2]);
                r4[n2] = i3, n2.match(/duration|pulse/) && (r4[n2] = "boolean" != typeof i3 ? 1e3 * i3 : i3);
              }
              return Object.assign({}, t4, r4);
            } }, { key: "registerEventListeners", value: function() {
              var e4 = this.elements;
              if (0 !== e4.length) if (this.intersectionSupport) {
                var t4 = new IntersectionObserver(this.animateElements.bind(this), { root: null, rootMargin: "20px", threshold: 0.5 });
                e4.forEach(function(e5) {
                  t4.observe(e5);
                });
              } else window.addEventListener && (this.animateLegacy(e4), window.addEventListener("scroll", function(t5) {
                this.animateLegacy(e4);
              }, { passive: true }));
            } }, { key: "animateLegacy", value: function(e4) {
              var t4 = this;
              e4.forEach(function(e5) {
                true === t4.parseConfig(e5).legacy && t4.elementIsInView(e5) && t4.animateElements([e5]);
              });
            } }, { key: "animateElements", value: function(e4, t4) {
              var r4 = this;
              e4.forEach(function(e5) {
                var n2 = e5.target || e5, i3 = r4.parseConfig(n2);
                if (i3.duration <= 0) return n2.innerHTML = r4.formatNumber(i3.end, i3);
                if (!t4 && !r4.elementIsInView(e5) || t4 && e5.intersectionRatio < 0.5) {
                  var o2 = i3.start > i3.end ? i3.end : i3.start;
                  return n2.innerHTML = r4.formatNumber(o2, i3);
                }
                setTimeout(function() {
                  return r4.startCounter(n2, i3);
                }, i3.delay);
              });
            } }, { key: "startCounter", value: function(e4, t4) {
              var r4 = this, n2 = (t4.end - t4.start) / (t4.duration / t4.delay), i3 = "inc";
              t4.start > t4.end && (i3 = "dec", n2 *= -1);
              var o2 = this.parseValue(t4.start);
              e4.innerHTML = this.formatNumber(o2, t4), true === t4.once && e4.setAttribute("data-purecounter-duration", 0);
              var a2 = setInterval(function() {
                var s2 = r4.nextNumber(o2, n2, i3);
                e4.innerHTML = r4.formatNumber(s2, t4), ((o2 = s2) >= t4.end && "inc" === i3 || o2 <= t4.end && "dec" === i3) && (e4.innerHTML = r4.formatNumber(t4.end, t4), t4.pulse && (e4.setAttribute("data-purecounter-duration", 0), setTimeout(function() {
                  e4.setAttribute("data-purecounter-duration", t4.duration / 1e3);
                }, t4.pulse)), clearInterval(a2));
              }, t4.delay);
            } }, { key: "parseConfig", value: function(e4) {
              var t4 = this, r4 = [].filter.call(e4.attributes, function(e5) {
                return /^data-purecounter-/.test(e5.name);
              }), i3 = 0 != r4.length ? Object.assign.apply(Object, [{}].concat(n(r4.map(function(e5) {
                var r5 = e5.name, n2 = e5.value;
                return function(e6, t5, r6) {
                  return t5 in e6 ? Object.defineProperty(e6, t5, { value: r6, enumerable: true, configurable: true, writable: true }) : e6[t5] = r6, e6;
                }({}, r5.replace("data-purecounter-", "").toLowerCase(), t4.parseValue(n2));
              })))) : {};
              return this.setOptions(i3, this.configOptions);
            } }, { key: "nextNumber", value: function(e4, t4) {
              var r4 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "inc";
              return e4 = this.parseValue(e4), t4 = this.parseValue(t4), parseFloat("inc" === r4 ? e4 + t4 : e4 - t4);
            } }, { key: "convertNumber", value: function(e4, t4) {
              if (t4.filesizing || t4.currency) {
                e4 = Math.abs(Number(e4));
                var r4 = 1e3, n2 = t4.currency && "string" == typeof t4.currency ? t4.currency : "", i3 = t4.decimals || 1, o2 = ["", "K", "M", "B", "T"], a2 = "";
                t4.filesizing && (r4 = 1024, o2 = ["bytes", "KB", "MB", "GB", "TB"]);
                for (var s2 = 4; s2 >= 0; s2--) if (0 === s2 && (a2 = "".concat(e4.toFixed(i3), " ").concat(o2[s2])), e4 >= this.getFilesizeThreshold(r4, s2)) {
                  a2 = "".concat((e4 / this.getFilesizeThreshold(r4, s2)).toFixed(i3), " ").concat(o2[s2]);
                  break;
                }
                return n2 + a2;
              }
              return parseFloat(e4);
            } }, { key: "getFilesizeThreshold", value: function(e4, t4) {
              return Math.pow(e4, t4);
            } }, { key: "applySeparator", value: function(e4, t4) {
              if (t4.formater) {
                var r4 = t4.separator ? "string" == typeof t4.separator ? t4.separator : "," : "";
                return "en-US" !== t4.formater && true === t4.separator ? e4 : (n2 = r4, e4.replace(/^(?:(\d{1,3},(?:\d{1,3},?)*)|(\d{1,3}\.(?:\d{1,3}\.?)*)|(\d{1,3}(?:\s\d{1,3})*))([\.,]?\d{0,2}?)$/gi, function(e5, t5, r5, i3, o2) {
                  var a2 = "", s2 = "";
                  if (void 0 !== t5 ? (a2 = t5.replace(new RegExp(/,/gi, "gi"), n2), s2 = ",") : void 0 !== r5 ? a2 = r5.replace(new RegExp(/\./gi, "gi"), n2) : void 0 !== i3 && (a2 = i3.replace(new RegExp(/ /gi, "gi"), n2)), void 0 !== o2) {
                    var u = "," !== s2 && "," !== n2 ? "," : ".";
                    a2 += o2.replace(new RegExp(/\.|,/gi, "gi"), u);
                  }
                  return a2;
                }));
              }
              var n2;
              return e4;
            } }, { key: "formatNumber", value: function(e4, t4) {
              var r4 = { minimumFractionDigits: t4.decimals, maximumFractionDigits: t4.decimals }, n2 = "string" == typeof t4.formater ? t4.formater : void 0;
              return e4 = this.convertNumber(e4, t4), e4 = t4.formater ? e4.toLocaleString(n2, r4) : parseInt(e4).toString(), this.applySeparator(e4, t4);
            } }, { key: "getLocaleSeparator", value: function() {
            } }, { key: "parseValue", value: function(e4) {
              return /^[0-9]+\.[0-9]+$/.test(e4) ? parseFloat(e4) : /^[0-9]+$/.test(e4) ? parseInt(e4) : /^true|false/i.test(e4) ? /^true/i.test(e4) : e4;
            } }, { key: "elementIsInView", value: function(e4) {
              for (var t4 = e4.offsetTop, r4 = e4.offsetLeft, n2 = e4.offsetWidth, i3 = e4.offsetHeight; e4.offsetParent; ) t4 += (e4 = e4.offsetParent).offsetTop, r4 += e4.offsetLeft;
              return t4 >= window.pageYOffset && r4 >= window.pageXOffset && t4 + i3 <= window.pageYOffset + window.innerHeight && r4 + n2 <= window.pageXOffset + window.innerWidth;
            } }, { key: "intersectionListenerSupported", value: function() {
              return "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in window.IntersectionObserverEntry.prototype;
            } }], r3 && a(t3.prototype, r3), i2 && a(t3, i2), Object.defineProperty(t3, "prototype", { writable: false }), e3;
          }();
        }, 634: function(e2, t2, r2) {
          var n = r2(3).Z;
          e2.exports = n;
        } }, t = {};
        function r(n) {
          var i = t[n];
          if (void 0 !== i) return i.exports;
          var o = t[n] = { exports: {} };
          return e[n](o, o.exports, r), o.exports;
        }
        return r.d = function(e2, t2) {
          for (var n in t2) r.o(t2, n) && !r.o(e2, n) && Object.defineProperty(e2, n, { enumerable: true, get: t2[n] });
        }, r.o = function(e2, t2) {
          return Object.prototype.hasOwnProperty.call(e2, t2);
        }, r(634);
      }();
    });
  }
});
export default require_purecounter();
/*! Bundled license information:

@srexi/purecounterjs/dist/purecounter.js:
  (*!
   * purecounter.js - A simple yet configurable native javascript counter which you can count on.
   * Author: Stig Rex
   * Version: 1.5.0
   * Url: https://github.com/srexi/purecounterjs
   * License: MIT
   *)
*/
//# sourceMappingURL=@srexi_purecounterjs.js.map
